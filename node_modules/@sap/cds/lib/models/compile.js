const cdsv = require('./cdsv')
const cds = require('../cds')
const path = require ('path')
const $ = Object.assign
const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }
// alpha fixes for gaps
const {unfold:_unfold_compositions} = require ('../alpha/_unfold_compositions')
const {unfold:_unfold_localized} = require ('../alpha/_localized')
const _skip_unused = require ('../alpha/_skip_unused')

const compile = (csn) => ({
  for: Object.assign ((x,o) => _fluent (compile_for,x, csn,o), {
    odata: (o)=> compile_for.odata (csn,o),
    hana: (o)=> compile_for.hana (csn,o),
    sql: (o)=> compile_for.sql (csn,o),
  }),
  to: Object.assign ((x,o) => _fluent (compile_to,x, csn,o), {
    'edmx-v2': (o)=> compile_to['edmx-v2'] (csn,o),
    'edmx-v4': (o)=> compile_to['edmx-v4'] (csn,o),
    edmx: (o)=> compile_to.edmx (csn,o),
    edm: (o)=> compile_to.edm (csn,o),
    yaml: (o)=> compile_to.yaml (csn,o),
    json: (o)=> compile_to.json (csn,o),
    sql: (o)=> compile_to.sql (csn,o),
    cdl: (o)=> compile_to.cdl (csn,o),
    hdi: (o)=> compile_to.hdi (csn,o),
    hana: (o)=> compile_to.hana (csn,o),
  }),
})

// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
function _fluent (compile_, to_or_for, csn, o) {
    let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
    if (typeof csn === 'string')  csn = cds.parse (csn)
    return fn (csn,o)
}

// Dedicated API, i.e. compile.for.odata(csn)
const compile_for = {
  odata: (csn,o) => { // we cache because cds-services calls us for every single service in a model
    const cached = csn._4odata; if (cached) return cached
    const csn4 = cdsv.forOData (csn,o);  /* cache it: */ Object.defineProperty (csn, '_4odata', {value: csn4})
    return $(csn4, { '@sql_mapping': o && o.sql_mapping || cds.env.sql_mapping })
  },
  sql: (csn,o) => cdsv.forSql (csn,o),
}

// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  yaml: YAML.stringify, yml: YAML.stringify,
  json: x => JSON.stringify(x,_2json,2),
  edmx: (csn,o) => _2edm (_unfold_compositions(csn),o, {off: 'metadata', only: 'annotations'}[o && o.annos]),
  'edmx-v2': (csn,o) => compile_to.edmx(csn,{...o,version:'v2'}),
  'edmx-v4': (csn,o) => compile_to.edmx(csn,{...o,version:'v4'}),
  edm: (csn,o) => _2edm (_unfold_compositions(csn),o, 'metadata_json'),
  annos: (csn,o) => _2edm (csn,o, 'annotations'),
  swgr: (csn,o) => _2many  (cdsv.toSwagger(csn,o).services, '.swgr.json'),
  cdl: (csn,o) => _2many (cdsv.toCdl(csn,o),'.cds'),
  sql: (csn,o) => _2sql (_unfold_localized (_sql (cdsv.toSql (_skip_unused(csn),o)), csn, o), o),
  hana: (csn,o) => _2many (cdsv.toHana(_skip_unused(csn),o).hdbcds, '.hdbcds'),
  hdi: (csn,o) => _2manyMap (cdsv.toHdi (csn, o)),
  hdbtabledata: (csn,o) => require('./2tabledata').create (csn,o),
  serviceinfo: (csn,o) => require('./2srvinfo') (csn,o),
  xsuaa: (csn,o) => require('./2xsuaa').xsuaaConfig (csn,o)
}

function _2json (key,v) {
  if (!v) return v

  else if (v.grant && v.where) try {
    // Add a parsed _where clause for @restrict.{grant,where} annotations
    return {...v, _where: JSON.stringify (cds.parse.xpr(v.where)) }
  } catch(e){/* ignored */}

  else if (v.kind === "service" && !v['@source'] && v.$location && v.$location.file) {
    // Preserve original sources for services so we can use them for finding
    // sibling implementation filed when reloaded from csn.json.
    return { '@source': v.$location.file.replace(/\\/g,'/'), ...v }
  }

  return v
}

/** Return output of 2hana as an iterable */
function* _2many (content, suffix='.hdbcds') {
  for (let each in content) yield [content[each], // content
    { name: each.replace(/[.:/\\]/g, '_'), suffix }
  ]
}

/** Return output of e.g. 2hdi for hdbtable/hdbview as an iterable */
function* _2manyMap(content) {
  for (let file of Object.keys(content)) {
    const {name, ext: suffix} = path.parse (file)
    yield [ content[file], { file, name, suffix } ]
  }
}

// TODO: remove that from cdsc
function _sql ({sql}) {
  const all=[]
  for (let e in sql)  all.push (sql[e].replace(/-- generated by.*\n/,'').replace(/;$/, ''))
  return all
}

/** Return output of 2sql as array of ddl statements or a concatenated string of which */
function _2sql (all, _o) {
  if (_o && _o.as === 'str') return '\n'+ all.join(';\n\n') +';\n'
  else return all
}

/** Return output of 2edm/x as a single json object or edmx string or as an iterable for all of which */
function _2edm (csn, o={}, what='combined') { // NOSONAR

  if (what === 'combined')  o.combined = true;  else o.separate = true
  if (what === 'metadata_json')  o.json = true;  else o.xml = true
  if (!o.version)  o.version = o.json ? 'v4' : cds.env.odata.version

  const {services} = cdsv.toOdata(csn,o) || {}
  const chosen = o.service

  if (chosen === 'all') { //> all services
    const all = function*(){ for (let s in services)  yield [ _result(s), {name:s} ] }
    return all()
  } else if (chosen) { //> a specific service
    const one = Object.keys(services).find (n => n.indexOf(chosen) >= 0)
    return one ? _result(one) : _not_found (chosen)
  } else { //> a single service
    const [one,many] = Object.keys(services)
    return many ? _choose_one_of(services) : _result(one)
  }

  function _result (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    const x = services[name][what]
    return o.as === 'str' && typeof x !== 'string' ? JSON.stringify(x) : x
  }
  function _choose_one_of (all) {
    throw new Error (`[cds] - multiple service definitions found in model; add one of...\n
    -s all ${Object.keys(all).map (each => `\n    -s ${each}`).join('')} \n`)
  }
  function _not_found (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    throw new Error (`[cds] - no service definition matching '${name}' found among...
    ${Object.keys(services).map (each => `\n   ${each}`).join('')} \n`)
  }

}


module.exports = Object.assign (compile, { to: compile_to, for: compile_for })

/* eslint no-console:off */
