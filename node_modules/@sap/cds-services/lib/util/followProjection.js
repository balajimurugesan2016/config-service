const _modifyData = (data, transition) =>
  Object.keys(data)
    .filter(key => transition.has(key))
    .forEach(key => {
      const value = data[key]
      data[transition.get(key)] = value
      delete data[key]
    })

const _modifyColumns = (columns, transition, withAlias = false) =>
  (columns || []).forEach(column => {
    const transitioned = column.ref && transition.get(column.ref[0])
    if (transitioned) {
      if (withAlias) {
        column.as = column.ref[0]
      }
      column.ref = [transition.get(column.ref[0])]
    }
  })

const _modifyEntries = (entries, transition) => (entries || []).forEach(entry => _modifyData(entry, transition))

const _modifyWhere = (where, transition) =>
  (where || [])
    .filter(whereElement => whereElement.ref)
    .forEach(whereElement => {
      const transitioned = transition.get(whereElement.ref[0])
      if (transitioned) {
        whereElement.ref = [transitioned]
      }
    })

const _isProjectionToRemotService = (query, service) =>
  query._target &&
  query._target.$syntax === 'projection' &&
  query._target.query &&
  query._target.source.startsWith(service.name) &&
  !query._target.name.startsWith(service.name)

const _handleUpdate = (query, transition) => {
  query.UPDATE.entity = query._target.source
  _modifyData(query.UPDATE.data, transition)
}

const _handleSelect = (query, transition) => {
  query.SELECT.from.ref = [query._target.source]
  if (!query.SELECT.columns) {
    query.SELECT.columns = query._target.query.SELECT.columns.map(column => ({
      ref: [column.as || column.ref[0]]
    }))
  }
  _modifyColumns(query.SELECT.columns, transition, true)
  _modifyColumns(query.SELECT.having, transition)
  _modifyColumns(query.SELECT.groupBy, transition)
  _modifyColumns(query.SELECT.orderBy, transition)
}

const _handleInsert = (query, transition) => {
  query.INSERT.into = query._target.source
  _modifyEntries(query.INSERT.entries, transition)
}

const _handleDelete = (query, transition) => {
  query.DELETE.from = query._target.source
}

module.exports = (query, service) => {
  // If the query is a projection, one must follow it
  // to let the underlying service know its true entity.

  if (_isProjectionToRemotService(query, service)) {
    const transitionColumns = query._target.query.SELECT.columns || []
    const transition = new Map()
    for (const transitionColumn of transitionColumns) {
      if (transitionColumn.as) {
        transition.set(transitionColumn.as, transitionColumn.ref[0])
      }
    }
    for (const prop in query) {
      _modifyWhere(query[prop].where, transition)
      if (prop === 'UPDATE') {
        _handleUpdate(query, transition)
      } else if (prop === 'SELECT') {
        _handleSelect(query, transition)
      } else if (prop === 'INSERT') {
        _handleInsert(query, transition)
      } else if (prop === 'DELETE') {
        _handleDelete(query, transition)
      }
    }
    query.target = query._target.query.target
  }
}
