const { extend } = require ('./mixins')

class any {

	constructor(...aspects){
		this.set ('name')
		aspects.length && extend(this) .with (...aspects)
	}

	/**
	 * Allows mixins to a single builtin class
	 * @example
	 * cds.entity.mixin (class { foo(){} })
	 * cds.builtin.classes.any.mixin (class { foo(){} })
	 */
	static mixin (...aspects) { extend(this.prototype) .with ( ...aspects); return this }

	/**
	 * Allows mixins to a single builtin class prototype
	 * @example
	 * cds.entity.prototype.mixin (class { foo(){} })
	 * cds.builtin.types.any.mixin (class { foo(){} })
	 */
	mixin (...aspects) { return extend(this) .with (...aspects) }

	set kind(k) { this.set('kind',k,true) }
	get kind(){
		return this.set ('kind', this.parent ? 'element' : this.query ? 'entity' : 'type')
	}

	is (kind) {
		if (typeof kind === 'function')  return this instanceof kind
		if (kind === 'struct')  return this.elements !== undefined
		else return this.kind === kind
	}
	own (property) {
		let pd = Reflect.getOwnPropertyDescriptor (this, property)
		if (pd)  return pd.value || pd.get(this)
	}
	set (property, value, enumerable=false) {
		Reflect.defineProperty (this, property, { value, enumerable, writable:1, configurable:1 })
		return value
	}
	valueOf() {
		return this.name
	}
}


class entity extends any {

	is (kind) {
		if (kind === 'view')  return this.query !== undefined
		return kind === 'entity' || kind === 'struct' || super.is(kind)
	}

	set keys(k) { this.set('_keys',k) }
	get keys() {
		const pd = Reflect.getOwnPropertyDescriptor(this,'_keys')
		if (pd) return pd.value
		let ee = this.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
		return this.keys = keys
	}

}


class Association extends any {

	is (kind) {
		return kind === 'Association' || this.type.endsWith(kind) || super.is(kind)
	}

    get is2many() { return !this.is2one }
	get is2one() {
		let c = this.cardinality
		return !c || c.max === 1 || !c.max && !c.targetMax || c.targetMax === 1
	}

	set _elements(k) { this.set('_elements',k) }
	get _elements() {
		const {keys} = this; if (!keys)  return this._elements = undefined
		const fks={}, {elements} = this._target
		for (let k of keys)  fks[k.as || k.ref[0]] = elements [k.ref[0]]
		return this._elements = fks
	}

	set _keys(k) { this.set('keys',k) }
	get _keys() {
		if (this.keys)  return this._keys = this.keys
		if (this.on || this.is2many || !this._target)  return this._keys = undefined
		const keys=[], tks = this._target.keys
		for (let k in tks)  keys.push ({ ref: [tks[k].name] })
		return this._keys = keys
	}
}


class service extends any {
}


/**
 * Export is a dictionary of all builtin classes
 */
module.exports = {
	any, entity, Association, service,

	/**
	 * Turns an inbound dictionary of CSN definitions into a corresponding
	 * dictionary of es6 classes inheriting from each others according to
	 * the CSN type refs.
	 * @returns {object} a dictionary of all the constructed classes' prototypes
	 */
	bootstrap (defs) {
		const protos = { any: any.prototype }
		for (let name in defs) {
			const clazz = class extends this [defs[name].type || 'any'] {} //> expects defs are well-ordered
			if (name in this)  clazz.mixin (this[name]) //> mixin any, entity, Association prototypes
			protos[name] = Object.defineProperty (clazz.prototype, 'name', {value:name})
			this[name] = Object.defineProperty (clazz, 'name', {value:name})
		}
		return protos
	},

	/**
	 * Allows to mixin functions or properties to several equally named builtin classes
	 * @example
	 * cds.builtin.classes.mixin (
	 * 	class any { foo(){} },
	 * 	class entity { bar(){} }
	 * )
	 */
	mixin (...classes) {
		for (let each of classes) {
			const clazz = this[each.name]
			if (!clazz) throw new Error (`unknown class '${each.name}'`)
			clazz.mixin(each)
		}
		return this
	}
}
