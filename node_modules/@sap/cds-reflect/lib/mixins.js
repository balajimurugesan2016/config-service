/**
 * Add methods to a given object.
 * @param {Object} target - the object to extend
 * @example
 * extend(Object.prototype) .with (class { foo(){} })
 */
const extend = exports.extend = (target=this) => ({
    with (...aspects) {
        for (let each of aspects) {
            const aspect = each.prototype || each
            for (let p of Reflect.ownKeys(aspect)) {
                p in {constructor:1,prototype:1} || Reflect.defineProperty (
                    target, p, Reflect.getOwnPropertyDescriptor (aspect,p)
                )
            }
        }
        return target
    }
})

/**
 * Equip a given facade object with getters for lazy-loading modules instead
 * of static requires. There are two usage options:
 *
 * 1. Lazify a facade object:
 * @example
 * const facade = lazify ({
 *  sub: lazy => require ('./sub-module')
 * })
 *
 * 2. Lazify a module:
 * @example
 * require = lazify (module) //> turns require into a lazy one
 * const facade = module.exports = {
 *  sub: require ('./sub-module')
 * })
 *
 * Option 2 allows to keep tools support for cross-navigation, e.g. in VSCode.
 * In both cases, the first usage of `facade.sub` will load the sub module
 * using standard Node.js's `module.require` functions.
 */
const lazify = exports.lazify = (o) => {
    if (o.constructor === module.constructor) { // is it a Node.js module?
        extend(o).with ({ set exports(x) { extend(this).with ({ exports: lazify(x) }) } })
        return id => lazy => o.require(id)  // eslint-disable-line
    }
    for (let p of Reflect.ownKeys(o)) {
        let v = Reflect.getOwnPropertyDescriptor(o,p).value
        if (typeof v === 'function' && /^\(?lazy[,)\t =]/.test(v)) Reflect.defineProperty(o,p,{configurable:1,
            set:v => Reflect.defineProperty (o,p,{value:v, writable:1}),
            get:() => o[p] = v(p,o),
        })
    }
    return o
}
