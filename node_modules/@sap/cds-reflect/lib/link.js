const cds = require('../index'), _builtin = cds.builtin.types, {set} = cds.reflect
const { any, struct, array, context, service, entity, annotation } = _builtin
const _kinds = { annotation, context, service, entity, view:entity }
const _is_linked = Symbol ('is linked')

module.exports = function cds_linked (m) {
	const rm = cds.reflect(m,1)
	if (!rm[_is_linked]) {
		const defs = rm.definitions
		for (let each in defs) _link (defs[each], each, undefined, defs)
		set (rm, _is_linked, true)
	}
	return rm
}

// exports.definition = (d,name) => _link (d, name, undefined, this.definitions)

function _link (d, name, parent, defs) {
	if (name)  set (d,'name', name)
	if (parent)  set (d,'parent', parent)
	// NOTE: the lines below expect own properties only -> have to go before linking prototypes
	if (d.target)  set (d,'_target', _target (d.target,d,defs))
	if (d.via)  set (d,'_via', _target (d.via,d,defs))
	if (d.items)  _link (d.items, name,d,defs)
	for (let e in d.elements) _link (d.elements[e],e,d,defs)
	// link definitions prototype
	try { Object.setPrototypeOf (d,
		d.query ? _infer(d,defs) :
		d.type ? _typeof(d.type,defs) || _resolve (d.type,defs) :
		_kinds [d.kind] || ( // note: 'type' and 'element' have to be ignored
			d.elements ? struct :
			d.items ? array : any
		)
	)} catch(e) { throw new Error (
		`circular dependency thru ${d.name} > ${_protos(defs[d.type]).join(' > ')}`
	)}
	// link exposed entities to containing services
	if (d.kind === 'entity' && name) {
		const dot = name.lastIndexOf('.')
		if (dot >= 0) {
			const srv = defs [name.slice(0,dot)]
			if (srv && srv.kind === 'service') set (d,'_service',srv)
		}
	}
	return d
}

function _infer (view, defs) {
	// const {SELECT} = view.query;  if (!SELECT || !SELECT.from || !SELECT.from.ref)  return
	const target = cds.infer (view.query, defs)
	if (target)  Object.defineProperty (view,'source', {get:()=>target.name}) // REVISIT: setting .source for compatibility with runtimes only(!)
	return target || _unresolved ('invalid query?', entity)
}

function _protos (p) {
	for (var chain=[]; p && p.name; p = p.__proto__) chain.push (p.name)
	return chain
}

const _target = (x,d,defs) => typeof x === 'string' ? _resolve(x,defs) : _link(x,'<inline>',d,defs)
const _resolve = (x,defs) => defs[x] || _builtin[x] || (defs[x] = _unresolved(x))
const _typeof = ({ref},defs) => { if (ref) {
	let [head,...tail] = ref, t = _resolve (head,defs)
	for (let next of tail)  t = t.elements && t.elements[next] || _unresolved(ref.join(':'))
	return t
}}
const _unresolved = (x,p=any) => ({name:x, __proto__:p, isUnresolved:true})
