// CSN frontend - transform CSN into XSN

// Overview of properties in schema specifications (values in 'schema' dictionary):
//
// * 'internal', 'noPrefix', 'ignore': is PROPERTY really a known property?
// * 't': what is the type of the property? (a test and transform function)
// * 'optional', 'inKind': which sub properties are expected / is PROPERTY expected?
// * 'requires', 'onlyWith': which (sub) properties are (also) necessary?
// * 'xorGroup' (set via "xorGroups"): which properties cannot be used together?
// * 'defaultKind', 'validKinds': in a definition, which kind is valid / the default?
// * 'inValue' (set via "exprProperties"): in a def, put property into the XSN property 'value'?
// * 'argsSchemaProp': the 'args' CSN property is a bit context dependent...
//   TODO: use sub schema + compileSchema(), pass spec to transformers instead prop
// * 'zeroFor', 'zeroIgnore': used for parsing CSNs in the Version 0.1.0 format...

'use strict';

const { normalizeLocation, getMessageFunction } = require('../base/messages');
const { addToDict } = require('../base/dictionaries');

const typeProperties = [        // sync with definition in to-csn.js
  // do not include CSN v0.1.0 properties here:
  'target', 'elements', 'enum', 'items',
  'type', 'length', 'precision', 'scale', 'srid', 'localized',
  'keys', 'on',                 // only with 'target'
];
const exprProperties = [
  // do not include CSN v0.1.0 properties here:
  'ref', 'xpr', 'val', '#', 'func', 'SELECT','SET', // Core Compiler checks SELECT/SET
  'param', 'global', 'literal', 'args',             // only with 'ref'/'ref'/'val'/'func'
];

// Groups of properties which cannot be used together:
const xorGroups = {
  // include CSN v0.1.0 properties here:
  ':type': ['target', 'elements', 'enum', 'items'],
  ':expr': [
    'ref', 'xpr', 'val', '#', 'func', 'SELECT', 'SET',
    '=', 'path', 'value', 'op', // '='/'path' is CSN v0.1.0 here
  ],
  ':ext': ['annotate', 'extend'],
  ':assoc': ['on', 'keys', 'foreignKeys', 'onCond'], // 'foreignKeys'/'onCond' is CSN v0.1.0
  ':join': ['join', 'as'],
  'scope': ['param', 'global'],
  'quantifier': ['some', 'any', 'distinct', 'all'],
  // quantifiers 'some' and 'any are 'xpr' token strings in CSN v1.0
}

const schema = compileSchema( {
  // internal: ---------------------------------------------------------------
  ':csn': {
    internal: true,             // not really a valid property
    type: object,
    optional: ['definitions', 'extensions', 'namespace', 'version', 'messages', 'meta', 'options'],
    requires: false,            // empty object OK
  },
  ':ignore': {                  // can be probably removed...
    internal: true, prop: '<???>',
    type: ignore,
  },
  // definitions: ------------------------------------------------------------
  definitions: {
    dictionaryOf: definition, defaultKind: 'type', validKinds: [
      'entity', 'type', 'action', 'function', 'context', 'service', 'event', 'annotation'
    ],
    // requires: { entity: ['elements', 'query', 'includes'] } - not really, make it work w/o elements
  },
  extensions: {
    arrayOf: definition, defaultKind: 'annotate', validKinds: [], // use annotate/extend instead of kind
  },
  enum: {
    dictionaryOf: definition, defaultKind: 'enum', validKinds: ['enum'],
    inKind: ['element', 'type', 'param', 'annotation', 'annotate' ],
  },
  elements: {
    dictionaryOf: definition, defaultKind: 'element', validKinds: ['element'],
    inKind: ['element', 'type', 'entity', 'param', 'annotation', 'annotate', 'extend'],
  },
  payload: {
    dictionaryOf: definition, type: renameTo( 'elements', dictionary ),
    defaultKind: 'element', validKinds: [],
    inKind: ['event'],
  },
  actions: {
    dictionaryOf: definition, defaultKind: 'action', validKinds: ['action','function'],
    inKind: ['entity', 'annotate'],
  },
  params: {
    dictionaryOf: definition, defaultKind: 'param', validKinds: ['param'],
    inKind: ['entity', 'action', 'function', 'annotate'], // TODO: 'extend'?
  },
  mixin: {
    dictionaryOf: definition, defaultKind: 'element', validKinds: [], // XSN TODO: kind 'mixin' by parser
  },
  columns: {
    arrayOf: selectItem, defaultKind: '$column', validKinds: [], // pseudo kind '$column'
    requires: ['ref', 'xpr', 'val', '#', 'func', 'SELECT', 'SET'], // requires one of...
  },
  keys: {
    type: keys, defaultKind: 'key', validKinds: [],
    requires: 'ref',
    onlyWith: 'target', inKind: ['element', 'type', 'annotate'],
  },
  foreignKeys: {                 // CSN v0.1.0 property -> use 'keys'
    vZeroFor: 'keys', inKind: 0,
    dictionaryOf: definition, defaultKind: 'key', validKinds: [],
  },
  // kind and name: ----------------------------------------------------------
  kind: {
    type: validKind, inKind: ':valid', // allowed in definitions with non-empty validKinds
  },
  annotate: {
    type: kindAndName, inKind: ['annotate'],
  },
  extend: {
    type: kindAndName, inKind: ['extend'],
  },
  as: {
    // remark: 'as' does not count as "proper" property in standard check that an object has >0 props
    type: explicitName,
    inKind: ['$column', 'key'],
  },
  // type properties (except: elements, enum, keys, on): ---------------------
  type: {
    type: artifactRef, optional: ['ref', 'global'],
    inKind: ['element', 'type', 'param', 'mixin', 'annotation'],
  },
  target: {
    type: artifactRef, optional: ['elements'], // 'elements' for ad-hoc COMPOSITION OF (gensrc style CSN)
    inKind: ['element', 'type', 'mixin'],
  },
  cardinality: {
    type: object, optional: ['src', 'min', 'max'],
    inKind: ['element', 'type', 'mixin'], onlyWith: ['target', 'id'], // also in 'ref[]'
  },
  items: {
    type: object, optional: typeProperties, // TODO: think of items: {}, then requires: false
    inKind: ['element', 'type', 'param', 'annotation'],
  },
  localized: {
    type: boolOrNull,
    inKind: ['element', 'type', 'param', 'annotation'],
  },
  length: {
    type: natnum,
    inKind: ['element', 'type', 'param', 'annotation'],
    // we do not require a 'type', too - could be useful alone in a 'cast'
  },
  precision: {
    type: natnum,
    inKind: ['element', 'type', 'param', 'annotation'],
  },
  scale: {
    type: natnum,
    inKind: ['element', 'type', 'param', 'annotation'],
  },
  srid: {
    type: natnum,
    inKind: ['element', 'type', 'param', 'annotation'],
  },
  src: {
    type: renameTo( 'sourceMax', natnumOrStar ),
  },
  min: {
    type: renameTo( 'targetMin', natnum ),
  },
  max: {
    type: renameTo( 'targetMax', natnumOrStar ),
  },
  sourceMax: {
    vZeroFor: 'src', type: natnumOrStar,
  },
  targetMin: {
    vZeroFor: 'min', type: natnum,
  },
  targetMax: {
    vZeroFor: 'max', type: natnumOrStar,
  },
  // expression properties (except: SELECT, SET): ----------------------------
  ref: {
    arrayOf: refItem, type: renameTo( 'path', arrayOf( refItem ) ), minLength: 1,
    requires: 'id', optional: ['id', 'args', 'cardinality', 'where'],
    inKind: ['$column', 'key'],
  },
  id: {                         // in refItem
    type: string,
  },
  param: {
    type: asScope,              // is bool, stored as string in XSN property 'scope'
    onlyWith: 'ref', inKind: ['$column'],
  },
  global: {
    type: asScope,              // is bool, stored as string in XSN property 'scope'
    onlyWith: 'ref', inKind: ['$column'],
  },
  func: {
    type: func,
    inKind: ['$column'],
  },
  args: {
    arrayOf: exprOrString, dictionaryOf: expr, type: args, optional: exprProperties,
    onlyWith: ['func', 'id', 'op'], inKind: ['$column'],
  },
  xpr: {
    arrayOf: exprOrString, type: xpr, optional: exprProperties,
    inKind: ['$column'],
  },
  val: {
    type: value,
    inKind: ['$column', 'enum'],
  },
  literal: {
    type: literal,
    onlyWith: 'val', inKind: ['$column', 'enum'],
  },
  '#': {
    noPrefix: true,             // schema spec for '#', not for '#whatever'
    type: symbol,
    inKind: ['$column'],
  },
  'path': {                     // in CSN v0.1.0 'foreignKeys'
    vZeroFor: 'ref', inKind: 0, inValue: true,
    type: vZeroRef,
  },
  '=': {                        // v0.1.0 { "=": "A.B" } for v1.0 { "ref": ["A", "B"] }
    vZeroFor: 'ref', inKind: 0, // still used in annotation assignments...
    type: vZeroRef,             // ...see property '@' / function annotation()
  },
  // primary query properties: -----------------------------------------------
  query: {
    type: object, optional: ['SELECT', 'SET'],
    inKind: ['entity'],
  },
  SELECT: {
    type: queryTerm,
    requires: 'from', optional: [
      'from', 'mixin', 'all', 'distinct', 'columns', 'excluding',
      'where', 'groupBy', 'having', 'orderBy', 'limit'
    ],
    inKind: ['$column'],
  },
  SET: {
    type: queryTerm,
    requires: 'args', optional: ['op', 'all', 'distinct', 'args', 'orderBy', 'limit'],
    argsSchemaProp: 'args:query', // TODO: remove
    schema: {
      args: {
        arrayOf: object, type: queryArgs, minLength: 1, optional: ['SELECT', 'SET'],
      },
    },
    inKind: ['$column'],
  },
  'args:query': { internal: true, type: queryArgs, optional: ['SELECT', 'SET'], minLength: 1 }, // TODO: remove
  op: {                                   // used for UNION etc in CSN v1.0
    vZeroFor: 'xpr', vZeroIgnore: 'call', // is also used in CSN v0.1.0 for "normal" expressions
    type: setOp,
    onlyWith: 'args',
  },
  join: {
    type: join,                 // string like 'cross' - TODO: test for valid ones?
  },
  from: {
    type: from,                // XSN TODO: no array anymore, then type: object
    optional: ['ref', 'global', 'join', 'args', 'on', 'SELECT', 'SET', 'as'],
    argsSchemaProp: 'args:from', // TODO: remove
    schema: {
      args: {
        arrayOf: object, minLength: 2,
        optional: ['ref', 'global', 'join', 'args', 'on', 'SELECT', 'SET', 'as'],
        onlyWith: 'join',
      },
    },
  },
  'args:from': {                                                         // for from.args
    internal: true,
    type: arrayOf( object, 'args[]', 'args' ), arrayOf: object, minLength: 2,
    onlyWith: 'join',
    argsSchemaProp: 'args:from',
    optional: ['ref', 'global', 'join', 'args', 'on', 'SELECT', 'SET', 'as'],
  },
  some: { type: asQuantifier }, // probably just CSN v0.1.0
  any: { type: asQuantifier },  // probably just CSN v0.1.0
  distinct: { type: asQuantifier },
  all: { type: asQuantifier },           // XSN TODO: use quantifier also for UNION etc
  // further query properties: -----------------------------------------------
  excluding: {
    arrayOf: string, type: renameTo( 'exclude', excluding ), // XSN TODO: exclude->excluding
  },
  on: {
    arrayOf: exprOrString, type: onCondition, optional: exprProperties,
    onlyWith: ['target', 'join'], inKind: ['element', 'mixin'],
  }, // XSN TODO: no 'onCond', then simply expression
  onCond: {
    vZeroFor: 'on', inKind: 0,
    type: expr, optional: exprProperties,
  },
  where: {
    arrayOf: exprOrString, type: condition, optional: exprProperties,
  },
  groupBy: {
    arrayOf: expr, optional: exprProperties,
  },
  having: {
    arrayOf: exprOrString, type: condition, optional: exprProperties,
  },
  orderBy: {            // TODO XSN: make `sort` and `nulls` sibling properties
    arrayOf: orderBy, optional: ['sort', 'nulls', ...exprProperties],
  },
  sort: {
    type: stringVal,
  },
  nulls: {
    type: stringVal,            // TODO: test for valid ones?
  },
  limit: {                      // XSN TODO: structure like CSN, then type: object
    type: embed, requires: 'rows', optional: ['rows', 'offset'],
  },
  rows: {
    type: renameTo( 'limit', expr ), optional: exprProperties,
  },
  offset: {
    type: expr, optional: exprProperties,
  },
  // miscellaneous properties in definitions: --------------------------------
  '@': {                        // for all properties starting with '@'
    prop: '@<anno>',            // which property name do messages use for annotation assignments?
    type: annotation,
    inKind: ':all',             // allowed in all definitions (including columns and extensions)
  },
  abstract: {
    type: boolOrNull,
    inKind: ['entity', 'service'],
  },
  // dbType: boolOrNull,                // TODO: currently with --hana-flavor only
  key: {
    type: boolOrNull,
    inKind: ['element', '$column'],
  },
  masked: {
    type: boolOrNull,
    inKind: ['element'],
  },
  notNull: {
    type: boolOrNull,
    inKind: ['element', 'param'], // TODO: $column  - or if so: in 'cast'?
  },
  // unique: boolOrNull,                // TECHNICAL CONFIGURATION only
  virtual: {
    type: boolOrNull,
    inKind: ['element']
  },
  cast: {
    type: embed, optional: typeProperties,
    inKind: ['$column'],
  },
  default: {
    type: expr, optional: exprProperties,
    inKind: ['element'],
  },
  includes: {
    arrayOf: stringRef,
    inKind: ['entity', 'type'],
  },
  returns: {
    type: object, optional: typeProperties,
    inKind: ['action', 'function'],
  },
  technicalConfig: {            // TODO: spec, re-check
    type: extra,
    inKind: ['entity'],
  },
  $syntax: {
    type: string,
    inKind: ['entity'],
  },
  origin: {                     // old-style CSN
    type: vZeroDelete, ignore: true,
  },
  source: {                     // CSN v0.1.0 query not supported
    type: ignore,
  },
  value: {
    vZeroFor: 0,                // CSN v0.1.0 property, but handled specially
    type: vZeroValue, optional: exprProperties,
    inKind: ['$column', 'enum'],
  },
  // ignored: ----------------------------------------------------------------
  $location: {                  // special
    ignore: true, type: ignore,
  },
  $generatedFieldName: {
    ignore: true, type: ignore, // TODO: do we need to do something?
  },
  namespace: {                  // unspecified top-level property by Umbrella
    type: ignore,
  },
  meta: {                       // meta information
    type: ignore,               // TODO: should we test s/th here?
  },
  version: {                    // deprecated top-level property
    type: ignore,
  },
  messages: {                   // deprecated top-level property
    type: ignore,
  },
  options: {                    // deprecated top-level property
    type: ignore,
  },
  indexNo: {                    // CSN v0.1.0, but ignored without message
    ignore: true, type: ignore,
  },
  '$': { type: ignore, ignore: true }, // including $env
  '_': { type: ignore, ignore: true },
} );

const validLiteralsExtra = Object.assign( Object.create(null), {
  // TODO: should we use quotedLiteralPatterns from genericAntlrParser?
  number: 'string',
  x: 'string',
  time: 'string',
  date: 'string',
  timestamp: 'string',
} );

// TODO: also have stricter tests for strings in in xpr/args, join, op, sort, nulls ?

// TODO: consider evil CSNs where 'kind' (with non-default value) is provided
// as non-enumerable or via prototype.  Similar probably for other properties.

function compileSchema( specs, proto = null) {
  // no prototype to protect against evil-CSN properties 'toString' etc.
  const r = Object.assign( Object.create( proto ), specs );
  for (const p of Object.keys( specs )) {
    const s = r[p];
    if (!s.prop)
      s.prop = p;
    if (!s.propMsg)
      s.propMsg = (s.arrayOf || s.dictionaryOf) ? s.prop + '[]' : s.prop;
    if (s.schema || proto)
      s.schema = compileSchema( s.schema || {}, r );
    if (!s.type)
      s.type = s.arrayOf ? arrayOf( s.arrayOf ) : dictionary;
  }
  if (proto)
    return r;
  for (const group in xorGroups) {
    for (const prop of xorGroups[group]) {
      if (r[prop].xorGroup === undefined)
        r[prop].xorGroup = group;
    }
  }
  for (const prop of exprProperties) {
    if (r[prop].inValue === undefined)
      r[prop].inValue = true;
  }
  return r;
}

let message = () => undefined;
let overwritingDefaultKind = null;

let csnVersionZero = false;
let csnFilename = '';
let virtualLine = 1;
let dollarLocations = [];
let validKinds = [];

function augment( csn, filename, options ) {
  csnVersionZero = csn.version && csn.version.csn === '0.1.0';
  csnFilename = filename;
  virtualLine = 1;
  dollarLocations = [];
  const xsn = { $frontend: 'json' };
  message = getMessageFunction( xsn, options );
  // TODO: pass transformers to pass schema spec instead prop
  if (csnVersionZero) {
    message( 'syntax-csn-zero-version', location(true), null, {},
             'Warning', 'Parsing CSN version 0.1.0' );
  }
  const r = object( csn, null, null, ':csn' );
  delete r.location;            // TODO XSN: use location instead extra filename XSN prop
  return Object.assign( xsn, r );
}

function ignore( obj ) {
  if (obj && typeof obj === 'object') {
    const array = (Array.isArray( obj )) ? obj : Object.values( obj );
    if (!array.length)
      return;                   // {}, [] in one JSON line
    virtualLine += 1 + array.length;
    array.forEach( ignore );
  }
}

function location( enforceJsonPos ) {
  return !enforceJsonPos && dollarLocations.length &&
         dollarLocations[ dollarLocations.length - 1] || {
           filename: csnFilename,
           start: { line: virtualLine, column: 0 },
           end: { line: virtualLine, column: 0 }, // TODO: $location in XSN
           $weak: true,
         };
}

function pushLocation( obj ) {
  // TODO: virtualLine is not really correct if $location is enumerable (is usually not)
  const loc = obj.$location;
  if (loc === undefined)
    return;
  if (loc && typeof loc === 'object' && !Array.isArray( loc )) {
    dollarLocations.push( normalizeLocation( loc ) );
    return;
  }
  else if (typeof loc === 'string') {                            // hidden feature: string $location
    const m = /:([0-9]+)(:([0-9]+)(-[0-9---]+)?)?$/.exec( loc ); // extra - at end for .refloc
    if (m) {
      const line = Number( m[1] );
      const column = m[3] && Number( m[3] ) || 0;
      dollarLocations.push( {
        filename: loc.substring( 0, m.index ),
        start: { line, column },
        end: { line, column },
        $weak: true,
      } );
      return;
    }
  }
  if (loc)
    dollarLocations.push( null ); // must match with popLocation()
  message( 'syntax-csn-expected-object', location(true), null, { prop: '$location' },
           'Error', 'Expected object for property $(PROP)' );
}

function popLocation( obj ) {
  if (obj.$location)
    dollarLocations.pop();
}

// Generic functions ---------------------------------------------------------

function validKind( val, xsn, csn, prop ) {
  if (typeof val === 'string' && validKinds.includes( val ))
    return val;
  if (!validKinds.length) {
    message( 'syntax-csn-unexpected-property', location(true), null, { prop },
             ['Error'], 'Unexpected CSN property $(PROP)' );
  }
  else if (val === 'view' && validKinds.includes( 'entity' )) {
    message( 'syntax-csn-zero-value', location(true), null, { prop },
             'Warning', 'Replace CSN v0.1.0 value in $(PROP) by something specified' );
    return 'entity';
  }
  else {
    message( 'syntax-csn-expected-valid', location(true), null, { prop },
             'Error', 'Expected valid string for property $(PROP)' );
  }
  return ignore( val );
}

function renameTo( xsnProp, func ) {
  return function( val, xsn, csn, prop ) {
    const r = func( val, xsn, csn, prop );
    if (r !== undefined)
      xsn[xsnProp] = r;
  }
}

function arrayOf( func, itemProp, arrayProp ) {
  // TODO: or use msgProp in schema, calculated by compileSchema()
  return function arrayMap( val, xsn, csn, prop ) {
    if (Array.isArray(val)) {
      if (!itemProp)
        itemProp = prop + '[]';
      const r = val.map( v => {
        ++virtualLine;
        return func( v, xsn, csn, prop, undefined, itemProp ) || { location: location() };
      } );
      const minLength = schema[prop] && schema[prop].minLength || 0;
      if (minLength > val.length) {
        message( 'syntax-csn-expected-length', location(true), null,
                 { prop, n: minLength, '#': minLength === 1 ? 'one' : 'std' },
                 'Error', {
                   std: 'Expected array in $(PROP) to have at least $(N) items',
                   one: 'Expected array in $(PROP) to have at least one item'
                 } );
      }
      if (val.length)
        ++virtualLine;          // [] in one JSON line
      return r;
    }
    message( 'syntax-csn-expected-array', location(true), null, { prop: arrayProp || prop },
             'Error', 'Expected array for property $(PROP)' );
    return ignore( val );
  };
}

function isArray( array, prop ) {
  if (Array.isArray( array ))
    return array;
  message( 'syntax-csn-expected-array', location(true), null, { prop },
           'Error', 'Expected array for property $(PROP)' );
  return ignore( array );
}

function isObject( obj, prop, msgid = 'syntax-csn-expected-object' ) {
  if (obj && typeof obj === 'object' && !Array.isArray( obj ))
    return obj;
  message( msgid, location(true), null, { prop }, 'Error' );
  return ignore( obj );
}

function replaceZeroProp( prev_prop, prop ) {
  if (csnVersionZero)
    return;
  message( 'syntax-csn-zero-prop', location(true), null, { prop, prev_prop },
           'Warning', 'Replace CSN v0.1.0 property $(PREV_PROP) by $(PROP)' );
}

function replaceZeroValue( prop ) {
  if (csnVersionZero || !prop)
    return;
  message( 'syntax-csn-zero-value', location(true), null, { prop },
           'Warning', 'Replace CSN v0.1.0 value in $(PROP) by something specified' );
}

function getSchema( csn, prop, xor, expected ) {
  const p0 = schema[prop] ? prop : prop.charAt(0);
  const s = schema[p0];
  if (!s || s.internal || s.noPrefix && prop !== p0 ) {
    message( 'syntax-csn-unknown-property', location(true), null, { prop },
             'Warning', 'Unknown CSN property $(PROP)' );
  }
  else if (!s.ignore && !expected( p0, s )) {
    if (s.vZeroIgnore && s.vZeroIgnore === csn[prop]) { // for "op": "call"
      message( 'syntax-csn-zero-delete', location(true), null, { prop },
               'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
      return { type: ignore };
    }
    const zero = s.vZeroFor;
    if (zero) {                 // (potential) CSN v0.1.0 property
      const group = s.xorGroup;
      if (zero && expected( zero, schema[zero] ) && !(group && xor[group])) {
        replaceZeroProp( prop, zero );
        if (group)
          xor[group] = prop;
        onlyWith( s, s.onlyWith, csn, prop, xor, expected );
        return s;
      }
    }
    message( 'syntax-csn-unexpected-property', location(true), null, { prop },
             ['Error'], 'Unexpected CSN property $(PROP)' );
    // TODO in $(SUPER) / in an element definition etc
    // TODO: or still augment it? (but then also handle xorGroup)
  }
  else if (checkAndSetXorGroup( s.xorGroup, prop, xor )) {
    onlyWith( s, s.onlyWith, csn, prop, xor, expected );
    return s;
  }
  // else ignore
  return { type: ignore };
}

function onlyWith( spec, need, csn, prop, xor, expected ) {
  if (!need)
    return spec;
  if (typeof need === 'string') {
    if (need in csn)            // TODO: enumerable ?
      return spec;
  }
  else if (need.some( n => n in csn )) {
    return spec;
  }
  else {
    const allowed = need.filter( p => expected( p, spec ));
    // There should be at least one elem, otherwise the spec is wrong;
    // first try to find element which is not excluded
    need = allowed.find( p => !xor[ schema[p].xorGroup ] ) || allowed[0];
  }
  if (prop) {
    message( 'syntax-csn-dependent-property', location(true), null,
             { prop, prev_prop: need }, 'Error',
             'CSN property $(PROP) can only be used in combination with $(PREV_PROP)');
    xor['no:req'] = prop;
  }
  else if (!xor['no:req']){
    message( 'syntax-csn-required-property', location(true), null,
             { prop: need, '#': prop === 0 ? '$column' : 'std' },
             'Error', {  // TODO $(PARENT), TODO: do not use prop===0 hack
               std: 'Object must have the property $(PROP)',
               $column: 'Object in \'column[]\' must have an expression property like $(PROP)'
             } );
  }
  return spec;
}

function checkAndSetXorGroup( group, prop, xor ) {
  if (!group)
    return true;
  if (!xor[group]) {
    xor[group] = prop;
    return true;
  }
  message( 'syntax-csn-excluded-property', location(true), null,
           { prop, prev_prop: xor[group] }, 'Error',
           'CSN property $(PROP) can only be used alternatively to $(PREV_PROP)');
  return false;
}

function object( obj, xsn, csn, prop, msgid, msgProp ) {
  if (!isObject( obj, msgProp || prop, msgid ))
    return undefined;
  pushLocation( obj );
  const r = { location: location() };
  const xor = {};
  const csnProps = Object.keys( obj );
  const objSchema = schema[prop] || schema[prop.charAt(0)]; // nec for requires
  if (csnProps.length) {
    ++virtualLine;
    const expected = (p => objSchema.optional.includes(p));
    for (let p of csnProps) {
      const argsProp = p === 'args' && objSchema.argsSchemaProp;
      const s = (argsProp) ? schema[argsProp] : getSchema( obj, p, xor, expected );
      const val = s.type( obj[p], r, obj, argsProp || p );
      if (val !== undefined)
        r[p] = val;
      ++virtualLine;
    }
  }
  const requires = objSchema.requires;
  if (requires === undefined || requires === true) {
    // console.log(csnProps,JSON.stringify(objSchema))
    if (!csnProps.length || csnProps.length === 1 && csnProps[0] === 'as')
      message( 'syntax-csn-required-subproperty', location(true), null,
               { prop: msgProp || prop, '#': csnProps.length ? 'as' : 'std' },
               'Error', {
                 std: 'Object in $(PROP) must have at least one property',
                 as: 'Object in $(PROP) must have at least one property other than \'as\''
               } );
  }
  else if (requires) {
    // console.log(csnProps,JSON.stringify(objSchema))
    onlyWith( objSchema, requires, obj, null, xor, () => true );
  }
  popLocation( obj );
  return r;
}

function embed( obj, xsn, csn, prop ) {
  if (prop === 'cast')          // XSN TODO: make sure that $inferred is enough
    xsn[csn.cast.target ? 'redirected' : '_typeIsExplicit'] = true;
  Object.assign( xsn, object( obj, xsn, csn, prop ) ); // TODO: $location?
}

// Definitions of artifacts and members, dictionaries and arrays -------------

function definition( def, xsn, csn, prop, name ) {
  const defSchema = schema[prop];
  if (!isObject( def, prop + '[]' ))
    return {
      kind: overwritingDefaultKind || defSchema.defaultKind,
      name: { id: '', path: [], absolute: name, location: location() },
      location: location(),
    }; // TODO: re-check
  pushLocation( def );
  validKinds = defSchema.validKinds;
  const kind = validKinds.includes( def.kind )
        ? def.kind
        : overwritingDefaultKind || defSchema.defaultKind;
  const r = (kind === '$column') ? { location: location() } : { location: location(), kind };
  const xor = {};
  const csnProps = Object.keys( def );
  if (csnProps.length) {
    const valueName = (prop === 'keys' || prop === 'foreignKeys' ? 'targetElement' : 'value');
    const kind0 = (prop === 'mixin' ? 'mixin' : kind);
    const expected = ((p,s) => Array.isArray(s.inKind) ? s.inKind.includes( kind0 ) : s.inKind);
    // the next is basically object() + the inValue handling
    ++virtualLine;
    for (let p of csnProps) {
      const s = getSchema( def, p, xor, expected );
      const v = !s.inValue && r || r[valueName] || (r[valueName] = { location: location() });
      const val = s.type( def[p], v, def, p );
      if (val !== undefined)
        v[p] = val;
      ++virtualLine;
    }
  }
  if (!r.name && name) {
    r.name = { id: name, location: r.location };
    if (prop === 'columns' || prop === 'keys' || prop === 'foreignKeys')
      r.name.$inferred = 'as';
    // TODO the following 'if' (if necessary) should be part of the core compiler
    if (prop === 'definitions')
      // xsn.name.path = name.split('.').map( id => ({ id, location: location() }) );
      r.name = {
        absolute: name,
        id: name.substring( name.lastIndexOf('.') + 1 ),
        path: [{ id: name, location: r.location }],
        location: r.location,
      };
  }
  if (defSchema.requires) {
    onlyWith( defSchema, defSchema.requires, def, 0, xor, () => true );
  }
  popLocation( def );
  return r;
}

function dictionary( dict, xsn, csn, prop ) {
  if (!isObject( dict, prop ))
    return undefined;
  if (csn.SELECT)               // do not augment hidden 'elements' for 'SELECT'
    return undefined;
  if (prop === 'definitions')
    overwritingDefaultKind = false;
  const r = Object.create(null);
  const allNames = Object.keys( dict );
  if (!allNames.length)
    return r;                   // {} in one JSON line
  ++virtualLine;
  for (let name of allNames) {
    r[name] = definition( dict[name], r, dict, prop, name );
    ++virtualLine;
  }
  return r;
}

function keys( array, xsn, csn, prop ) {
  if (!isArray( array, prop ))
    return;
  const r = Object.create(null);
  ++virtualLine;
  for (let def of array) {
    const id = def.as || implicitName( def.ref );
    const name = (typeof id === 'string') ? id : '';
    // definer will complain about repeated names
    addToDict( r, name, definition( def, r, array, prop, name ) );
    ++virtualLine;
  }
  xsn.foreignKeys = r;
}

function implicitName( ref ) {
  // careful, the input CSN might be wrong!
  const item = ref && ref[ ref.length - 1 ];
  return (typeof item === 'object') ? item && item.id : item;
}

function selectItem( def, xsn, csn, prop ) {
  if (def === '*') {
    return { val: '*', location: location() };
  }
  else {
    return isObject( def, 'columns[]', 'syntax-csn-expected-column' ) &&
           definition( def, xsn, csn, prop, null ); // definer sets name
  }
}

function excluding( array, xsn, csn, prop ) {
  if (!isArray( array, prop ))
    return undefined;
  const r = Object.create(null);
  ++virtualLine;
  for (let id of array) {
    // TODO: complain about repeated id in definer
    addToDict( r, id, { name: { id, location: location() }, location: location() },
               ( name, loc ) => {
                 message( 'duplicate-excluding', loc, null, { name },
                          'Error', 'Duplicate EXCLUDING for source element $(NAME)' );
               } );
    ++virtualLine;
  }
  return r;
}

function kindAndName( id, xsn, csn, prop ) {
  xsn.kind = prop;
  if (!string( id, xsn, csn, prop ))
    return;
  xsn.name = { path: [{ id, location: location() }], location: location() };
  overwritingDefaultKind = (prop === 'annotate') && 'annotate';
}

function explicitName( id, xsn, csn, prop ) {
  if (string( id, xsn, csn, prop ))
    xsn.name = { id, location: location() };
}

// References, Values --------------------------------------------------------

function artifactRef( ref, xsn, csn, prop ) {
  if (!ref || typeof ref !== 'string')
    return object( ref, xsn, csn, prop, 'syntax-csn-expected-reference' );
  if (prop !== 'type' || !csnVersionZero)
    return stringRef( ref, xsn, csn, prop );
  // now the CSN v0.1.0 type of: 'Artifact..e1.e2'
  const idx = ref.indexOf('..');
  if (idx < 0)
    return stringRef( ref, xsn, csn, prop );
  const r = refSplit( ref.substring( idx + 2 ), prop );
  r.path.unshift( { id: ref.substring( 0, idx ), location: location() } );
  return r;
}

function stringRef( ref, xsn, csn, prop ) {
  return string( ref, xsn, csn, prop ) &&
    { path: [ { id: ref, location: location() } ], location: location() };
}

function refItem( item, xsn, csn, prop ) {
  if (typeof item === 'string' && item)
    return { id: item, location: location() };
  else
    return isObject( item, prop + '[]', 'syntax-csn-expected-reference' ) &&
           object( item, xsn, csn, prop, 'syntax-csn-expected-reference' );
}

function refSplit( name, prop ) {
  const path = name.split('.');
  if (!path.every( id => id)) {
    message( 'syntax-csn-expected-name', location(true), null, { prop },
             'Warning', 'Expected correct name for property $(PROP)' );
  }
  return { path: path.map( id => ({ id, location: location() }) ), location: location() };
}

function asScope( scope, xsn, csn, prop ) {
  if (scope)
    xsn.scope = prop;
  boolOrNull( scope, xsn, csn, prop );
}

function boolOrNull( val, xsn, csn, prop ) {
  if ([true, false, null].includes( val ))
    return { val, location: location() };
  message( 'syntax-csn-expected-boolean', location(true), null, { prop },
           'Warning', 'Expected boolean or null for property $(PROP)' );
  ignore( val );
  return { val: !!val, location: location() };
}

function string( val, xsn, csn, prop ) {
  if (typeof val === 'string' && val)
    //  XSN TODO: do not require literal
    return val;
  message( 'syntax-csn-expected-string', location(true), null, { prop },
           'Error', 'Expected non-empty string for property $(PROP)' );
  return ignore( val );
}
function stringVal( val, xsn, csn, prop ) {
  if (typeof val === 'string' && val)
    //  XSN TODO: do not require literal
    return { val, literal: 'string', location: location() };
  message( 'syntax-csn-expected-string', location(true), null, { prop },
           'Error', 'Expected non-empty string for property $(PROP)' );
  return ignore( val );
}

function natnum( val, xsn, csn, prop, msgid = 'syntax-csn-expected-natnum' ) {
  if (typeof val === 'number' && val >= 0)
    //  XSN TODO: do not require literal
    return { val, literal: 'number', location: location() };
  message( msgid, location(true), null, { prop }, 'Error' );
  return ignore( val );
}

function natnumOrStar( val, xsn, csn, prop ) {
  return (val === '*')
    ? { val, literal: 'string', location: location() }
    : natnum( val, xsn, csn, prop, 'syntax-csn-expected-cardinality' );
}

function annoValue( val ) {
  if (val == null)              // TODO: reject undefined
    return { val, literal: 'null', location: location() };
  const literal = typeof val;
  if (literal !== 'object')
    return { val, literal, location: location() };
  if (Array.isArray( val )) {
    return {
      location: location(),
      val: arrayOf( annoValue )( val ),
      literal: 'array',
    };
  }
  if (typeof val['#'] === 'string') {
    if (Object.keys( val ).length === 1) {
      virtualLine += 2;
      return { symbol: { id: val['#'], location: location() }, literal: 'enum', location: location() };
    }
  }
  else if (typeof val['='] === 'string') {
    if (Object.keys( val ).length === 1) {
      virtualLine += 2;
      return refSplit( val['='], '=' );
    }
  }
  const struct = Object.create(null);
  ++virtualLine;
  for (let name of Object.keys( val )) {
    struct[name] = annotation( val[name], null, val, name );
    ++virtualLine;
  }
  return { struct, literal: 'struct', location: location() };
}


function annotation( val, xsn, csn, name ) {
  const variantIndex = name.indexOf('#');
  const n = refSplit( name.substring( (xsn ? 1 : 0), variantIndex + 1 || name.length ), '{}' );
  if (!n)
    return undefined;
  if (variantIndex >= 0)
    n.variant = { id: name.substring( variantIndex + 1 ), location: location() };
  const r = annoValue( val );
  r.name = n;
  return r;
}

// Expressions, conditions, queries ------------------------------------------

function asQuantifier( quantifier, xsn, csn, prop ) {
  if (quantifier)
    xsn.quantifier = { val: prop, location: location() };
  boolOrNull( quantifier, xsn, csn, prop );
}

function queryTerm( term, xsn, csn, prop ) {
  if (!isObject( term, prop ))
    return;
  pushLocation( term );
  if (prop === 'SELECT')
    xsn.op = { val: 'query', location: location() }; // TODO: 'SELECT'
  else if (!term.op)
    xsn.op = { val: 'subquery', location: location() };
  Object.assign( xsn, object( term, xsn, csn, prop ) );
  popLocation( term );
}

function setOp( val, xsn, csn, prop ) { // UNION, ...
  // similar to string(), but without literal, and with csn.all hack
  return string( val, xsn, csn, prop ) &&
    { val: (csn.all && val === 'union' ? 'unionAll' : val), location: location() };
}

function join( val, xsn, csn, prop ) {
  if (!string( val, xsn, csn, prop ))
    return undefined;
  xsn.op = { val: 'join', location: location() };
  return val;
}

function value( val, xsn, csn, prop ) {
  if (!csn.literal)
    xsn.literal = (val === null) ? 'null' : typeof val;
  if ((val == null) ? val === null : typeof val !== 'object')
    return val;
  message( 'syntax-csn-expected-scalar', location(true), null, { prop },
           'Error', 'Only scalar values are supported for property $(PROP)' );
  return ignore( val );
}

function literal( val, xsn, csn, prop ) {
  // TODO: general: requires other property (here: 'val')
  const type = (csn.val == null) ? 'null' : typeof csn.val;
  if (val === type)            // also for 'object' which is an error for 'val'
    return val;
  if (typeof val === 'string' && validLiteralsExtra[val] === type)
    return (val === 'x' ? 'raw' : val); // XSN TODO: 'raw'->'x'
  message( 'syntax-csn-expected-valid', location(true), null, { prop },
           'Error', 'Expected valid string for property $(PROP)' );
  return ignore( val );
}

function symbol( id, xsn, csn, prop ) {
  if (!string( id, xsn, csn, prop ))
    return;
  if (!csn.literal)
    xsn.literal = 'enum';
  xsn.symbol = { id, location: location() };
}

function vZeroValue( obj, xsn, csn, prop ) {
  if (xsn.value) {
    // TODO: also "sign" xsn.value created by inValue to complain about both 'value' and 'ref' etc
    message( 'syntax-csn-unexpected-property', location(true), null, { prop },
             'Warning', 'Unexpected CSN property $(PROP)' );
    return undefined;
  }
  if (!csnVersionZero) {
    message( 'syntax-csn-zero-delete', location(true), null, { prop },
             'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
  }
  if (Array.isArray( obj ) && obj.length === 1) {
    return [expr( obj[0], xsn, 0, prop ) || { location: location() }];
  }
  else if (obj === null || ['string', 'number', 'boolean'].includes( typeof obj )) { //  && schema[prop].optional.includes( 'val' )) {
    return annoValue( obj );
  }
  return object( obj, xsn, csn, prop );
}

function vZeroDelete( o, xsn, csn, prop ) {
  if (!csnVersionZero) {
    message( 'syntax-csn-zero-delete', location(true), null, { prop },
             'Warning', 'Delete/inline CSN v0.1.0 property $(PROP)' );
  }
  string( o, xsn, csn, prop );
}

function vZeroRef( name, xsn, csn, prop ) {
  if (!string( name, xsn, csn, prop ))
    return;
  const path = name.split('.');
  if (!path.every( id => id)) {
    message( 'syntax-csn-expected-name', location(true), null, { prop },
             'Warning', 'Expected correct name for property $(PROP)' );
  }
  xsn.path = path.map( id => ({ id, location: location() }) );
}

function func( val, xsn, csn, prop ) {
  if (!string( val, xsn, csn, prop ))
    return undefined;
  xsn.op = { val: 'call', location: location() };
  return { path: [ { id: val, location: location() } ], location: location() };
}

function xpr( exprs, xsn, csn, prop ) {
  xsn.op = { val: 'xpr', location: location() };
  xsn.args = arrayOf( exprOrString )( exprs, xsn, csn, prop );
}

function args( exprs, xsn, csn, prop ) {
  if (Array.isArray( exprs ))
    return arrayOf( exprOrString )( exprs, xsn, csn, prop );
  if (!isObject( exprs, prop, 'syntax-csn-expected-args'))
    return undefined;
  const r = Object.create(null);
  ++virtualLine;
  for (let name of Object.keys( exprs )) {
    const a = expr( exprs[name], xsn, csn, prop );
    if (a) {
      a.name = { id: name, location: a.location };
      r[name] = a;
    }
    ++virtualLine;
  }
  xsn.namedArgs = r;
  return undefined;
}

function from( val, xsn, csn, prop ) {
  return [object( val, xsn, csn, prop )];     // XSN TODO: no array
}

function queryArgs( val, xsn, csn, prop ) {
  if (Array.isArray( val ) && val.length > 1 && !csn.op) {
    message( 'syntax-csn-expected-property', location(true), null, { prop: 'args', prev_prop: 'op' },
             'Warning', 'CSN property $(PROP) expects property $(PREV_PROP) to be specified' );
    xsn.op = { val: 'union', location: location() };
  }
  return arrayOf( object, 'args[]', 'args' )( val, xsn, csn, prop );
}

function expr( e, xsn, csn, prop, msgid = 'syntax-csn-expected-object' ) {
  if (Array.isArray( e ) && e.length === 1) {
    replaceZeroValue( csn && prop );
    return [expr( e[0], xsn, 0, prop ) || { location: location() }];
  }
  else if (e === null || ['string', 'number', 'boolean'].includes( typeof e )) { //  && schema[prop].optional.includes( 'val' )) {
    replaceZeroValue( csn && prop );
    return annoValue( e );
  }
  return object( e, xsn, csn, prop, msgid );
}

function exprOrString( e, xsn, csn, prop ) {
  return (typeof e === 'string' && !csnVersionZero)
    ? e
    : expr( e, xsn, csn, prop, 'syntax-csn-expected-reference' );
}

function condition( cond, xsn, csn, prop ) {
  const loc = location();
  return {
    op: { val: 'xpr', location: loc },
    args: arrayOf( exprOrString )( cond, xsn, csn, prop ),
    location: loc };
}

function onCondition( cond, xsn, csn, prop ) {
  if (!csn.target)
    return condition( cond, xsn, csn, prop );
  xsn.onCond = condition( cond, xsn, csn, prop );
  return undefined;
}

function orderBy( node, xsn, csn, prop ) {
  const value = expr( node, xsn, csn, prop );
  if (!value)
    return undefined;
  const r = { value, location: value.location };
  if (value.sort) {
    r.sort = value.sort;
    delete value.sort;
  }
  if (value.nulls) {
    r.nulls = value.nulls;
    delete value.nulls;
  }
  return r;
}

function extra( node, xsn, csn, prop ) {
  if (!xsn.$extra)
    xsn.$extra = Object.create(null);
  xsn.$extra[prop] = node;
}

function parse( source, filename = 'csn.json', options = {} ) {
  try {
    return augment( JSON.parse(source), filename, options );
  }
  catch( e ) {
    if (!(e instanceof SyntaxError))
      throw e;
    const xsn = {};
    const message = getMessageFunction( xsn, options );
    const msg = e.message;
    const p = /in JSON at position ([0-9]+)/.exec( msg );
    let line = 1;
    let column = 0;
    if (p) {
      const end = Number( p[1] );
      let eol = 0;
      let nl = /\n/g;
      while (nl.test( source )) {
        if (nl.lastIndex >= end)
          break;
        eol = nl.lastIndex;
        ++line;
      }
      column = end - eol + 1;
    }
    const location = { filename, start: { line, column }, end: { line, column }, $weak: true };
    message( 'syntax-csn-illegal-json', location, null, { msg },
             'Error', 'Illegal JSON: $(MSG)' );
    return xsn;
  }
}

module.exports = { augment, parse };
